import{dR as W,bF as k,dS as z,c5 as Y,dT as B,bH as Z,dU as w,dV as R,cT as tt,dW as et,dX as nt,bI as ot,cy as st,dY as ct,bG as at}from"./index-CyCqcZIQ.js";/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */let X;const F=t=>X=t,q=Symbol();function x(t){return t&&typeof t=="object"&&Object.prototype.toString.call(t)==="[object Object]"&&typeof t.toJSON!="function"}var P;(function(t){t.direct="direct",t.patchObject="patch object",t.patchFunction="patch function"})(P||(P={}));function ht(){const t=W(!0),c=t.run(()=>k({}));let n=[],e=[];const u=z({install(a){F(u),u._a=a,a.provide(q,u),a.config.globalProperties.$pinia=u,e.forEach(r=>n.push(r)),e=[]},use(a){return this._a?n.push(a):e.push(a),this},_p:n,_a:null,_e:t,_s:new Map,state:c});return u}const D=()=>{};function T(t,c,n,e=D){t.push(c);const u=()=>{const a=t.indexOf(c);a>-1&&(t.splice(a,1),e())};return!n&&et()&&nt(u),u}function m(t,...c){t.slice().forEach(n=>{n(...c)})}const rt=t=>t(),V=Symbol(),J=Symbol();function M(t,c){t instanceof Map&&c instanceof Map?c.forEach((n,e)=>t.set(e,n)):t instanceof Set&&c instanceof Set&&c.forEach(t.add,t);for(const n in c){if(!c.hasOwnProperty(n))continue;const e=c[n],u=t[n];x(u)&&x(e)&&t.hasOwnProperty(n)&&!w(e)&&!R(e)?t[n]=M(u,e):t[n]=e}return t}const ut=Symbol();function it(t){return!x(t)||!Object.prototype.hasOwnProperty.call(t,ut)}const{assign:l}=Object;function ft(t){return!!(w(t)&&t.effect)}function pt(t,c,n,e){const{state:u,actions:a,getters:r}=c,j=n.state.value[t];let h;function d(){j||(n.state.value[t]=u?u():{});const y=ct(n.state.value[t]);return l(y,a,Object.keys(r||{}).reduce((b,_)=>(b[_]=z(at(()=>{F(n);const v=n._s.get(t);return r[_].call(v,v)})),b),{}))}return h=G(t,d,c,n,e,!0),h}function G(t,c,n={},e,u,a){let r;const j=l({actions:{}},n),h={deep:!0};let d,y,b=[],_=[],v;const O=e.state.value[t];!a&&!O&&(e.state.value[t]={}),k({});let U;function A(o){let s;d=y=!1,typeof o=="function"?(o(e.state.value[t]),s={type:P.patchFunction,storeId:t,events:v}):(M(e.state.value[t],o),s={type:P.patchObject,payload:o,storeId:t,events:v});const i=U=Symbol();st().then(()=>{U===i&&(d=!0)}),y=!0,m(b,s,e.state.value[t])}const H=a?function(){const{state:o}=n,s=o?o():{};this.$patch(i=>{l(i,s)})}:D;function K(){r.stop(),b=[],_=[],e._s.delete(t)}const C=(o,s="")=>{if(V in o)return o[J]=s,o;const i=function(){F(e);const E=Array.from(arguments),$=[],I=[];function N(f){$.push(f)}function Q(f){I.push(f)}m(_,{args:E,name:i[J],store:p,after:N,onError:Q});let g;try{g=o.apply(this&&this.$id===t?this:p,E)}catch(f){throw m(I,f),f}return g instanceof Promise?g.then(f=>(m($,f),f)).catch(f=>(m(I,f),Promise.reject(f))):(m($,g),g)};return i[V]=!0,i[J]=s,i},L={_p:e,$id:t,$onAction:T.bind(null,_),$patch:A,$reset:H,$subscribe(o,s={}){const i=T(b,o,s.detached,()=>E()),E=r.run(()=>ot(()=>e.state.value[t],$=>{(s.flush==="sync"?y:d)&&o({storeId:t,type:P.direct,events:v},$)},l({},h,s)));return i},$dispose:K},p=Z(L);e._s.set(t,p);const S=(e._a&&e._a.runWithContext||rt)(()=>e._e.run(()=>(r=W()).run(()=>c({action:C}))));for(const o in S){const s=S[o];if(w(s)&&!ft(s)||R(s))a||(O&&it(s)&&(w(s)?s.value=O[o]:M(s,O[o])),e.state.value[t][o]=s);else if(typeof s=="function"){const i=C(s,o);S[o]=i,j.actions[o]=s}}return l(p,S),l(tt(p),S),Object.defineProperty(p,"$state",{get:()=>e.state.value[t],set:o=>{A(s=>{l(s,o)})}}),e._p.forEach(o=>{l(p,r.run(()=>o({store:p,app:e._a,pinia:e,options:j})))}),O&&a&&n.hydrate&&n.hydrate(p.$state,O),d=!0,y=!0,p}/*! #__NO_SIDE_EFFECTS__ */function dt(t,c,n){let e;const u=typeof c=="function";e=u?n:c;function a(r,j){const h=B();return r=r||(h?Y(q,null):null),r&&F(r),r=X,r._s.has(t)||(u?G(t,c,e,r):pt(t,e,r)),r._s.get(t)}return a.$id=t,a}export{dt as d,ht as h};
