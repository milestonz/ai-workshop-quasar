import{br as N,Z as q,bs as z,g as Y,bt as B,W as G,bu as w,bv as D,as as tt,bw as nt,bx as et,$ as st,af as ot,by as at,o as ct}from"./index-Bw1AfG2u.js";/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */let H;const x=t=>H=t,K=Symbol();function k(t){return t&&typeof t=="object"&&Object.prototype.toString.call(t)==="[object Object]"&&typeof t.toJSON!="function"}var E;(function(t){t.direct="direct",t.patchObject="patch object",t.patchFunction="patch function"})(E||(E={}));function ht(){const t=N(!0),a=t.run(()=>q({}));let e=[],n=[];const i=z({install(c){x(i),i._a=c,c.provide(K,i),c.config.globalProperties.$pinia=i,n.forEach(r=>e.push(r)),n=[]},use(c){return this._a?e.push(c):n.push(c),this},_p:e,_a:null,_e:t,_s:new Map,state:a});return i}const L=()=>{};function C(t,a,e,n=L){t.push(a);const i=()=>{const c=t.indexOf(a);c>-1&&(t.splice(c,1),n())};return!e&&nt()&&et(i),i}function S(t,...a){t.slice().forEach(e=>{e(...a)})}const rt=t=>t(),J=Symbol(),W=Symbol();function A(t,a){t instanceof Map&&a instanceof Map?a.forEach((e,n)=>t.set(n,e)):t instanceof Set&&a instanceof Set&&a.forEach(t.add,t);for(const e in a){if(!a.hasOwnProperty(e))continue;const n=a[e],i=t[e];k(i)&&k(n)&&t.hasOwnProperty(e)&&!w(n)&&!D(n)?t[e]=A(i,n):t[e]=n}return t}const it=Symbol();function ut(t){return!k(t)||!Object.prototype.hasOwnProperty.call(t,it)}const{assign:l}=Object;function ft(t){return!!(w(t)&&t.effect)}function pt(t,a,e,n){const{state:i,actions:c,getters:r}=a,$=e.state.value[t];let h;function y(){$||(e.state.value[t]=i?i():{});const b=at(e.state.value[t]);return l(b,c,Object.keys(r||{}).reduce((d,_)=>(d[_]=z(ct(()=>{x(e);const v=e._s.get(t);return r[_].call(v,v)})),d),{}))}return h=Q(t,y,a,e,n,!0),h}function Q(t,a,e={},n,i,c){let r;const $=l({actions:{}},e),h={deep:!0};let y,b,d=[],_=[],v;const O=n.state.value[t];!c&&!O&&(n.state.value[t]={}),q({});let F;function M(s){let o;y=b=!1,typeof s=="function"?(s(n.state.value[t]),o={type:E.patchFunction,storeId:t,events:v}):(A(n.state.value[t],s),o={type:E.patchObject,payload:s,storeId:t,events:v});const u=F=Symbol();ot().then(()=>{F===u&&(y=!0)}),b=!0,S(d,o,n.state.value[t])}const R=c?function(){const{state:s}=e,o=s?s():{};this.$patch(u=>{l(u,o)})}:L;function T(){r.stop(),d=[],_=[],n._s.delete(t)}const Z=(s,o="")=>{if(J in s)return s[W]=o,s;const u=function(){x(n);const P=Array.from(arguments),g=[],I=[];function V(f){g.push(f)}function X(f){I.push(f)}S(_,{args:P,name:u[W],store:p,after:V,onError:X});let m;try{m=s.apply(this&&this.$id===t?this:p,P)}catch(f){throw S(I,f),f}return m instanceof Promise?m.then(f=>(S(g,f),f)).catch(f=>(S(I,f),Promise.reject(f))):(S(g,m),m)};return u[J]=!0,u[W]=o,u},U={_p:n,$id:t,$onAction:C.bind(null,_),$patch:M,$reset:R,$subscribe(s,o={}){const u=C(d,s,o.detached,()=>P()),P=r.run(()=>st(()=>n.state.value[t],g=>{(o.flush==="sync"?b:y)&&s({storeId:t,type:E.direct,events:v},g)},l({},h,o)));return u},$dispose:T},p=G(U);n._s.set(t,p);const j=(n._a&&n._a.runWithContext||rt)(()=>n._e.run(()=>(r=N()).run(()=>a({action:Z}))));for(const s in j){const o=j[s];if(w(o)&&!ft(o)||D(o))c||(O&&ut(o)&&(w(o)?o.value=O[s]:A(o,O[s])),n.state.value[t][s]=o);else if(typeof o=="function"){const u=Z(o,s);j[s]=u,$.actions[s]=o}}return l(p,j),l(tt(p),j),Object.defineProperty(p,"$state",{get:()=>n.state.value[t],set:s=>{M(o=>{l(o,s)})}}),n._p.forEach(s=>{l(p,r.run(()=>s({store:p,app:n._a,pinia:n,options:$})))}),O&&c&&e.hydrate&&e.hydrate(p.$state,O),y=!0,b=!0,p}/*! #__NO_SIDE_EFFECTS__ */function yt(t,a,e){let n;const i=typeof a=="function";n=i?e:a;function c(r,$){const h=B();return r=r||(h?Y(K,null):null),r&&x(r),r=H,r._s.has(t)||(i?Q(t,a,n,r):pt(t,n,r)),r._s.get(t)}return c.$id=t,c}export{yt as S,ht as y};
