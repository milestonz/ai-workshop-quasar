import{dQ as G,bE as H,dR as J,bS as Y,dS as Z,bG as B,dT as w,dU as N,cQ as tt,dV as nt,dW as et,bH as st,cD as ot,dX as at,bF as ct}from"./index-D1vT6N3s.js";/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */let U;const F=t=>U=t,V=Symbol();function I(t){return t&&typeof t=="object"&&Object.prototype.toString.call(t)==="[object Object]"&&typeof t.toJSON!="function"}var E;(function(t){t.direct="direct",t.patchObject="patch object",t.patchFunction="patch function"})(E||(E={}));function ht(){const t=G(!0),a=t.run(()=>H({}));let e=[],n=[];const u=J({install(c){F(u),u._a=c,c.provide(V,u),c.config.globalProperties.$pinia=u,n.forEach(r=>e.push(r)),n=[]},use(c){return this._a?e.push(c):n.push(c),this},_p:e,_a:null,_e:t,_s:new Map,state:a});return u}const X=()=>{};function W(t,a,e,n=X){t.push(a);const u=()=>{const c=t.indexOf(a);c>-1&&(t.splice(c,1),n())};return!e&&nt()&&et(u),u}function m(t,...a){t.slice().forEach(e=>{e(...a)})}const rt=t=>t(),k=Symbol(),C=Symbol();function Q(t,a){t instanceof Map&&a instanceof Map?a.forEach((e,n)=>t.set(n,e)):t instanceof Set&&a instanceof Set&&a.forEach(t.add,t);for(const e in a){if(!a.hasOwnProperty(e))continue;const n=a[e],u=t[e];I(u)&&I(n)&&t.hasOwnProperty(e)&&!w(n)&&!N(n)?t[e]=Q(u,n):t[e]=n}return t}const ut=Symbol();function it(t){return!I(t)||!Object.prototype.hasOwnProperty.call(t,ut)}const{assign:l}=Object;function ft(t){return!!(w(t)&&t.effect)}function pt(t,a,e,n){const{state:u,actions:c,getters:r}=a,O=e.state.value[t];let h;function d(){O||(e.state.value[t]=u?u():{});const y=at(e.state.value[t]);return l(y,c,Object.keys(r||{}).reduce((b,v)=>(b[v]=J(ct(()=>{F(e);const _=e._s.get(t);return r[v].call(_,_)})),b),{}))}return h=q(t,d,a,e,n,!0),h}function q(t,a,e={},n,u,c){let r;const O=l({actions:{}},e),h={deep:!0};let d,y,b=[],v=[],_;const S=n.state.value[t];!c&&!S&&(n.state.value[t]={}),H({});let A;function M(s){let o;d=y=!1,typeof s=="function"?(s(n.state.value[t]),o={type:E.patchFunction,storeId:t,events:_}):(Q(n.state.value[t],s),o={type:E.patchObject,payload:s,storeId:t,events:_});const i=A=Symbol();ot().then(()=>{A===i&&(d=!0)}),y=!0,m(b,o,n.state.value[t])}const z=c?function(){const{state:s}=e,o=s?s():{};this.$patch(i=>{l(i,o)})}:X;function D(){r.stop(),b=[],v=[],n._s.delete(t)}const R=(s,o="")=>{if(k in s)return s[C]=o,s;const i=function(){F(n);const P=Array.from(arguments),j=[],x=[];function L(f){j.push(f)}function T(f){x.push(f)}m(v,{args:P,name:i[C],store:p,after:L,onError:T});let $;try{$=s.apply(this&&this.$id===t?this:p,P)}catch(f){throw m(x,f),f}return $ instanceof Promise?$.then(f=>(m(j,f),f)).catch(f=>(m(x,f),Promise.reject(f))):(m(j,$),$)};return i[k]=!0,i[C]=o,i},K={_p:n,$id:t,$onAction:W.bind(null,v),$patch:M,$reset:z,$subscribe(s,o={}){const i=W(b,s,o.detached,()=>P()),P=r.run(()=>st(()=>n.state.value[t],j=>{(o.flush==="sync"?y:d)&&s({storeId:t,type:E.direct,events:_},j)},l({},h,o)));return i},$dispose:D},p=B(K);n._s.set(t,p);const g=(n._a&&n._a.runWithContext||rt)(()=>n._e.run(()=>(r=G()).run(()=>a({action:R}))));for(const s in g){const o=g[s];if(w(o)&&!ft(o)||N(o))c||(S&&it(o)&&(w(o)?o.value=S[s]:Q(o,S[s])),n.state.value[t][s]=o);else if(typeof o=="function"){const i=R(o,s);g[s]=i,O.actions[s]=o}}return l(p,g),l(tt(p),g),Object.defineProperty(p,"$state",{get:()=>n.state.value[t],set:s=>{M(o=>{l(o,s)})}}),n._p.forEach(s=>{l(p,r.run(()=>s({store:p,app:n._a,pinia:n,options:O})))}),S&&c&&e.hydrate&&e.hydrate(p.$state,S),d=!0,y=!0,p}/*! #__NO_SIDE_EFFECTS__ */function dt(t,a,e){let n;const u=typeof a=="function";n=u?e:a;function c(r,O){const h=Z();return r=r||(h?Y(V,null):null),r&&F(r),r=U,r._s.has(t)||(u?q(t,a,n,r):pt(t,n,r)),r._s.get(t)}return c.$id=t,c}export{dt as S,ht as y};
