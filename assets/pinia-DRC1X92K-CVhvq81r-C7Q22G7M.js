import{bs as L,j as V,bt as W,r as D,bu as G,s as Y,bv as w,bw as z,av as tt,bx as et,by as nt,H as st,aa as ot,bz as ct,b as at}from"./index-D1vT6N3s.js";/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */let K;const I=t=>K=t,N=Symbol();function A(t){return t&&typeof t=="object"&&Object.prototype.toString.call(t)==="[object Object]"&&typeof t.toJSON!="function"}var P;(function(t){t.direct="direct",t.patchObject="patch object",t.patchFunction="patch function"})(P||(P={}));function ht(){const t=L(!0),c=t.run(()=>V({}));let n=[],e=[];const u=W({install(a){I(u),u._a=a,a.provide(N,u),a.config.globalProperties.$pinia=u,e.forEach(r=>n.push(r)),e=[]},use(a){return this._a?n.push(a):e.push(a),this},_p:n,_a:null,_e:t,_s:new Map,state:c});return u}const Q=()=>{};function C(t,c,n,e=Q){t.push(c);const u=()=>{const a=t.indexOf(c);a>-1&&(t.splice(a,1),e())};return!n&&et()&&nt(u),u}function j(t,...c){t.slice().forEach(n=>{n(...c)})}const rt=t=>t(),J=Symbol(),M=Symbol();function F(t,c){t instanceof Map&&c instanceof Map?c.forEach((n,e)=>t.set(e,n)):t instanceof Set&&c instanceof Set&&c.forEach(t.add,t);for(const n in c){if(!c.hasOwnProperty(n))continue;const e=c[n],u=t[n];A(u)&&A(e)&&t.hasOwnProperty(n)&&!w(e)&&!z(e)?t[n]=F(u,e):t[n]=e}return t}const ut=Symbol();function it(t){return!A(t)||!Object.prototype.hasOwnProperty.call(t,ut)}const{assign:l}=Object;function pt(t){return!!(w(t)&&t.effect)}function ft(t,c,n,e){const{state:u,actions:a,getters:r}=c,O=n.state.value[t];let h;function b(){O||(n.state.value[t]=u?u():{});const y=ct(n.state.value[t]);return l(y,a,Object.keys(r||{}).reduce((d,v)=>(d[v]=W(at(()=>{I(n);const $=n._s.get(t);return r[v].call($,$)})),d),{}))}return h=R(t,b,c,n,e,!0),h}function R(t,c,n={},e,u,a){let r;const O=l({actions:{}},n),h={deep:!0};let b,y,d=[],v=[],$;const _=e.state.value[t];!a&&!_&&(e.state.value[t]={}),V({});let H;function k(s){let o;b=y=!1,typeof s=="function"?(s(e.state.value[t]),o={type:P.patchFunction,storeId:t,events:$}):(F(e.state.value[t],s),o={type:P.patchObject,payload:s,storeId:t,events:$});const i=H=Symbol();ot().then(()=>{H===i&&(b=!0)}),y=!0,j(d,o,e.state.value[t])}const T=a?function(){const{state:s}=n,o=s?s():{};this.$patch(i=>{l(i,o)})}:Q;function U(){r.stop(),d=[],v=[],e._s.delete(t)}const q=(s,o="")=>{if(J in s)return s[M]=o,s;const i=function(){I(e);const E=Array.from(arguments),g=[],x=[];function Z(p){g.push(p)}function B(p){x.push(p)}j(v,{args:E,name:i[M],store:f,after:Z,onError:B});let S;try{S=s.apply(this&&this.$id===t?this:f,E)}catch(p){throw j(x,p),p}return S instanceof Promise?S.then(p=>(j(g,p),p)).catch(p=>(j(x,p),Promise.reject(p))):(j(g,S),S)};return i[J]=!0,i[M]=o,i},X={_p:e,$id:t,$onAction:C.bind(null,v),$patch:k,$reset:T,$subscribe(s,o={}){const i=C(d,s,o.detached,()=>E()),E=r.run(()=>st(()=>e.state.value[t],g=>{(o.flush==="sync"?y:b)&&s({storeId:t,type:P.direct,events:$},g)},l({},h,o)));return i},$dispose:U},f=Y(X);e._s.set(t,f);const m=(e._a&&e._a.runWithContext||rt)(()=>e._e.run(()=>(r=L()).run(()=>c({action:q}))));for(const s in m){const o=m[s];if(w(o)&&!pt(o)||z(o))a||(_&&it(o)&&(w(o)?o.value=_[s]:F(o,_[s])),e.state.value[t][s]=o);else if(typeof o=="function"){const i=q(o,s);m[s]=i,O.actions[s]=o}}return l(f,m),l(tt(f),m),Object.defineProperty(f,"$state",{get:()=>e.state.value[t],set:s=>{k(o=>{l(o,s)})}}),e._p.forEach(s=>{l(f,r.run(()=>s({store:f,app:e._a,pinia:e,options:O})))}),_&&a&&n.hydrate&&n.hydrate(f.$state,_),b=!0,y=!0,f}/*! #__NO_SIDE_EFFECTS__ */function bt(t,c,n){let e;const u=typeof c=="function";e=u?n:c;function a(r,O){const h=G();return r=r||(h?D(N,null):null),r&&I(r),r=K,r._s.has(t)||(u?R(t,c,e,r):ft(t,e,r)),r._s.get(t)}return a.$id=t,a}export{ht as h,bt as y};
