import{gc as J,e1 as L,gd as N,ef as Z,ge as G,e3 as V,gf as E,gg as U,fd as tt,gh as et,gi as nt,e4 as st,f0 as ot,gj as at,e2 as ct}from"./index-CyCqcZIQ.js";/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */let z;const x=t=>z=t,B=Symbol();function F(t){return t&&typeof t=="object"&&Object.prototype.toString.call(t)==="[object Object]"&&typeof t.toJSON!="function"}var P;(function(t){t.direct="direct",t.patchObject="patch object",t.patchFunction="patch function"})(P||(P={}));function ht(){const t=J(!0),a=t.run(()=>L({}));let n=[],e=[];const i=N({install(c){x(i),i._a=c,c.provide(B,i),c.config.globalProperties.$pinia=i,e.forEach(r=>n.push(r)),e=[]},use(c){return this._a?n.push(c):e.push(c),this},_p:n,_a:null,_e:t,_s:new Map,state:a});return i}const D=()=>{};function q(t,a,n,e=D){t.push(a);const i=()=>{const c=t.indexOf(a);c>-1&&(t.splice(c,1),e())};return!n&&et()&&nt(i),i}function O(t,...a){t.slice().forEach(n=>{n(...a)})}const rt=t=>t(),C=Symbol(),Q=Symbol();function M(t,a){t instanceof Map&&a instanceof Map?a.forEach((n,e)=>t.set(e,n)):t instanceof Set&&a instanceof Set&&a.forEach(t.add,t);for(const n in a){if(!a.hasOwnProperty(n))continue;const e=a[n],i=t[n];F(i)&&F(e)&&t.hasOwnProperty(n)&&!E(e)&&!U(e)?t[n]=M(i,e):t[n]=e}return t}const it=Symbol();function ut(t){return!F(t)||!Object.prototype.hasOwnProperty.call(t,it)}const{assign:p}=Object;function ft(t){return!!(E(t)&&t.effect)}function lt(t,a,n,e){const{state:i,actions:c,getters:r}=a,j=n.state.value[t];let h;function y(){j||(n.state.value[t]=i?i():{});const d=at(n.state.value[t]);return p(d,c,Object.keys(r||{}).reduce((b,g)=>(b[g]=N(ct(()=>{x(n);const v=n._s.get(t);return r[g].call(v,v)})),b),{}))}return h=H(t,y,a,n,e,!0),h}function H(t,a,n={},e,i,c){let r;const j=p({actions:{}},n),h={deep:!0};let y,d,b=[],g=[],v;const _=e.state.value[t];!c&&!_&&(e.state.value[t]={}),L({});let A;function W(s){let o;y=d=!1,typeof s=="function"?(s(e.state.value[t]),o={type:P.patchFunction,storeId:t,events:v}):(M(e.state.value[t],s),o={type:P.patchObject,payload:s,storeId:t,events:v});const u=A=Symbol();ot().then(()=>{A===u&&(y=!0)}),d=!0,O(b,o,e.state.value[t])}const K=c?function(){const{state:s}=n,o=s?s():{};this.$patch(u=>{p(u,o)})}:D;function R(){r.stop(),b=[],g=[],e._s.delete(t)}const k=(s,o="")=>{if(C in s)return s[Q]=o,s;const u=function(){x(e);const w=Array.from(arguments),S=[],I=[];function X(f){S.push(f)}function Y(f){I.push(f)}O(g,{args:w,name:u[Q],store:l,after:X,onError:Y});let $;try{$=s.apply(this&&this.$id===t?this:l,w)}catch(f){throw O(I,f),f}return $ instanceof Promise?$.then(f=>(O(S,f),f)).catch(f=>(O(I,f),Promise.reject(f))):(O(S,$),$)};return u[C]=!0,u[Q]=o,u},T={_p:e,$id:t,$onAction:q.bind(null,g),$patch:W,$reset:K,$subscribe(s,o={}){const u=q(b,s,o.detached,()=>w()),w=r.run(()=>st(()=>e.state.value[t],S=>{(o.flush==="sync"?d:y)&&s({storeId:t,type:P.direct,events:v},S)},p({},h,o)));return u},$dispose:R},l=V(T);e._s.set(t,l);const m=(e._a&&e._a.runWithContext||rt)(()=>e._e.run(()=>(r=J()).run(()=>a({action:k}))));for(const s in m){const o=m[s];if(E(o)&&!ft(o)||U(o))c||(_&&ut(o)&&(E(o)?o.value=_[s]:M(o,_[s])),e.state.value[t][s]=o);else if(typeof o=="function"){const u=k(o,s);m[s]=u,j.actions[s]=o}}return p(l,m),p(tt(l),m),Object.defineProperty(l,"$state",{get:()=>e.state.value[t],set:s=>{W(o=>{p(o,s)})}}),e._p.forEach(s=>{p(l,r.run(()=>s({store:l,app:e._a,pinia:e,options:j})))}),_&&c&&n.hydrate&&n.hydrate(l.$state,_),y=!0,d=!0,l}/*! #__NO_SIDE_EFFECTS__ */function yt(t,a,n){let e;const i=typeof a=="function";e=i?n:a;function c(r,j){const h=G();return r=r||(h?Z(B,null):null),r&&x(r),r=z,r._s.has(t)||(i?H(t,a,e,r):lt(t,e,r)),r._s.get(t)}return c.$id=t,c}export{yt as S,ht as y};
